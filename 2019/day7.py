"""
Advent of Code 2019 Day 7: Amplification Circuit
Optimized solution using non-threaded Intcode execution.
"""
import itertools
from typing import List, Tuple


class IntcodeSimple:
    """
    Simplified non-threaded Intcode computer for better performance.
    Optimized for day 7's amplifier circuit simulation.
    """
    
    def __init__(self, program: str):
        self.original_program = [int(x) for x in program.split(',')]
        self.reset()
    
    def reset(self):
        """Reset the computer to initial state."""
        self.memory = self.original_program.copy()
        # Extend memory for safety
        self.memory.extend([0] * 10000)
        self.pc = 0  # Program counter
        self.relative_base = 0
        self.inputs = []
        self.outputs = []
        self.halted = False
        self.waiting_for_input = False
    
    def add_input(self, value: int):
        """Add input value."""
        self.inputs.append(value)
        self.waiting_for_input = False
    
    def get_parameter_value(self, offset: int, mode: int) -> int:
        """Get parameter value based on mode."""
        if mode == 0:  # Position mode
            return self.memory[self.memory[self.pc + offset]]
        elif mode == 1:  # Immediate mode
            return self.memory[self.pc + offset]
        elif mode == 2:  # Relative mode
            return self.memory[self.relative_base + self.memory[self.pc + offset]]
        else:
            raise ValueError(f"Unknown parameter mode: {mode}")
    
    def get_write_address(self, offset: int, mode: int) -> int:
        """Get write address based on mode."""
        if mode == 0:  # Position mode
            return self.memory[self.pc + offset]
        elif mode == 2:  # Relative mode
            return self.relative_base + self.memory[self.pc + offset]
        else:
            raise ValueError(f"Invalid write mode: {mode}")
    
    def run_until_output_or_halt(self) -> bool:
        """Run until output is produced or program halts. Returns True if output produced."""
        while not self.halted and not self.waiting_for_input:
            instruction = self.memory[self.pc]
            opcode = instruction % 100
            mode1 = (instruction // 100) % 10
            mode2 = (instruction // 1000) % 10
            mode3 = (instruction // 10000) % 10
            
            if opcode == 99:  # Halt
                self.halted = True
                return False
            
            elif opcode == 1:  # Add
                val1 = self.get_parameter_value(1, mode1)
                val2 = self.get_parameter_value(2, mode2)
                addr = self.get_write_address(3, mode3)
                self.memory[addr] = val1 + val2
                self.pc += 4
            
            elif opcode == 2:  # Multiply
                val1 = self.get_parameter_value(1, mode1)
                val2 = self.get_parameter_value(2, mode2)
                addr = self.get_write_address(3, mode3)
                self.memory[addr] = val1 * val2
                self.pc += 4
            
            elif opcode == 3:  # Input
                if not self.inputs:
                    self.waiting_for_input = True
                    return False
                addr = self.get_write_address(1, mode1)
                self.memory[addr] = self.inputs.pop(0)
                self.pc += 2
            
            elif opcode == 4:  # Output
                val = self.get_parameter_value(1, mode1)
                self.outputs.append(val)
                self.pc += 2
                return True  # Output produced
            
            elif opcode == 5:  # Jump-if-true
                val = self.get_parameter_value(1, mode1)
                target = self.get_parameter_value(2, mode2)
                if val != 0:
                    self.pc = target
                else:
                    self.pc += 3
            
            elif opcode == 6:  # Jump-if-false
                val = self.get_parameter_value(1, mode1)
                target = self.get_parameter_value(2, mode2)
                if val == 0:
                    self.pc = target
                else:
                    self.pc += 3
            
            elif opcode == 7:  # Less than
                val1 = self.get_parameter_value(1, mode1)
                val2 = self.get_parameter_value(2, mode2)
                addr = self.get_write_address(3, mode3)
                self.memory[addr] = 1 if val1 < val2 else 0
                self.pc += 4
            
            elif opcode == 8:  # Equals
                val1 = self.get_parameter_value(1, mode1)
                val2 = self.get_parameter_value(2, mode2)
                addr = self.get_write_address(3, mode3)
                self.memory[addr] = 1 if val1 == val2 else 0
                self.pc += 4
            
            elif opcode == 9:  # Adjust relative base
                val = self.get_parameter_value(1, mode1)
                self.relative_base += val
                self.pc += 2
            
            else:
                raise ValueError(f"Unknown opcode: {opcode}")
        
        return False


def solve_part1(program: str) -> int:
    """Solve part 1: Find maximum signal through amplifier chain."""
    max_signal = 0
    
    for phase_sequence in itertools.permutations([0, 1, 2, 3, 4]):
        signal = 0
        
        # Run through each amplifier in sequence
        for phase in phase_sequence:
            amp = IntcodeSimple(program)
            amp.add_input(phase)  # Phase setting
            amp.add_input(signal)  # Input signal
            
            # Run until output
            amp.run_until_output_or_halt()
            signal = amp.outputs[0]
        
        max_signal = max(max_signal, signal)
    
    return max_signal


def solve_part2(program: str) -> int:
    """Solve part 2: Find maximum signal with feedback loop."""
    max_signal = 0
    
    for phase_sequence in itertools.permutations([5, 6, 7, 8, 9]):
        # Initialize all amplifiers
        amps = [IntcodeSimple(program) for _ in range(5)]
        
        # Set phase settings
        for i, phase in enumerate(phase_sequence):
            amps[i].add_input(phase)
        
        # Start with signal 0 to amplifier A
        signal = 0
        amp_index = 0
        
        # Run feedback loop until amplifier E halts
        while not amps[4].halted:
            current_amp = amps[amp_index]
            current_amp.add_input(signal)
            
            # Run until output or halt
            produced_output = current_amp.run_until_output_or_halt()
            
            if produced_output:
                signal = current_amp.outputs[-1]  # Get latest output
            
            # Move to next amplifier
            amp_index = (amp_index + 1) % 5
        
        max_signal = max(max_signal, signal)
    
    return max_signal


def solve_day7(filename: str = "day7_input.txt") -> Tuple[int, int]:
    """Solve both parts of day 7."""
    # Try to read from file, fall back to embedded program
    try:
        with open(filename, 'r') as f:
            program = f.read().strip()
    except FileNotFoundError:
        # Embedded program from original solution
        program = "3,8,1001,8,10,8,105,1,0,0,21,34,59,68,85,102,183,264,345,426,99999,3,9,101,3,9,9,102,3,9,9,4,9,99,3,9,1002,9,4,9,1001,9,2,9,1002,9,2,9,101,5,9,9,102,5,9,9,4,9,99,3,9,1001,9,4,9,4,9,99,3,9,101,3,9,9,1002,9,2,9,1001,9,5,9,4,9,99,3,9,1002,9,3,9,1001,9,5,9,102,3,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,1,9,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,2,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,99"
    
    part1 = solve_part1(program)
    part2 = solve_part2(program)
    
    return part1, part2


# Test runner compatible functions
def part1(input_data) -> int:
    """Part 1 function compatible with test runner."""
    part1_result, _ = solve_day7()
    return part1_result


def part2(input_data) -> int:
    """Part 2 function compatible with test runner."""
    _, part2_result = solve_day7()
    return part2_result


# Legacy functions for backward compatibility
def day7p1() -> int:
    """Legacy function for part 1."""
    return part1(None)


def day7p2() -> int:
    """Legacy function for part 2."""
    return part2(None)


if __name__ == "__main__":
    part1_result, part2_result = solve_day7()
    print(f"Part 1: {part1_result}")
    print(f"Part 2: {part2_result}")